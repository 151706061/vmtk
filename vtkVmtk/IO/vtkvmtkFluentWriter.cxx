/*=========================================================================
                                                                                                                                    
Program:   VMTK
Module:    $RCSfile: vtkvmtkFluentWriter.cxx,v $
Language:  C++
Date:      $Date: 2006/04/06 16:47:47 $
Version:   $Revision: 1.6 $
                                                                                                                                    
  Copyright (c) Luca Antiga, David Steinman. All rights reserved.
  See LICENCE file for details.

  Portions of this code are covered under the VTK copyright.
  See VTKCopyright.txt or http://www.kitware.com/VTKCopyright.htm 
  for details.

     This software is distributed WITHOUT ANY WARRANTY; without even 
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
     PURPOSE.  See the above copyright notices for more information.
                                                                                                                                    
=========================================================================*/

// #include <fstream>

#include "vtkvmtkFluentWriter.h"
#include "vtkUnstructuredGrid.h"
#include "vtkCellType.h"
#include "vtkCell.h"
#include "vtkCellData.h"
#include "vtkIntArray.h"
#include "vtkIdTypeArray.h"
#include "vtkObjectFactory.h"
#include "vtkvmtkConstants.h"

vtkCxxRevisionMacro(vtkvmtkFluentWriter, "$Revision: 1.6 $");
vtkStandardNewMacro(vtkvmtkFluentWriter);

vtkvmtkFluentWriter::vtkvmtkFluentWriter()
{
  this->BoundaryDataArrayName = NULL;
}

vtkvmtkFluentWriter::~vtkvmtkFluentWriter()
{
  if (this->BoundaryDataArrayName)
    {
    delete[] this->BoundaryDataArrayName;
    this->BoundaryDataArrayName = NULL;
    }
}

void vtkvmtkFluentWriter::WriteData()
{
  vtkUnstructuredGrid *input= vtkUnstructuredGrid::SafeDownCast(this->GetInput());

  if (!this->FileName)
    {
    vtkErrorMacro(<<"FileName not set.");
    return;
    }
        
  ofstream out (this->FileName);

  if (!out.good())
    {
    vtkErrorMacro(<<"Could not open file for writing.");
    return;
    }
  
  input->BuildLinks();

  int numberOfPoints = input->GetNumberOfPoints();
  int numberOfCells = input->GetNumberOfCells();

  vtkIntArray* boundaryDataArray = vtkIntArray::New();
  if (this->BoundaryDataArrayName)
    {
    if (input->GetCellData()->GetArray(this->BoundaryDataArrayName))
      {
      boundaryDataArray->DeepCopy(input->GetCellData()->GetArray(this->BoundaryDataArrayName));
      }
    else
      {
      vtkErrorMacro(<<"BoundaryDataArray with name specified does not exist");
      boundaryDataArray->Delete();
      return;
      }
    }
  else
    {
    boundaryDataArray->SetNumberOfValues(numberOfCells);
    boundaryDataArray->FillComponent(0,0.0);
    }

  vtkIdTypeArray* tetraCellIdArray = vtkIdTypeArray::New();
  input->GetIdsOfCellsOfType(VTK_TETRA,tetraCellIdArray);
  int numberOfTetras = tetraCellIdArray->GetNumberOfTuples();

  vtkIdList* tetraCellIdMap = vtkIdList::New();
  tetraCellIdMap->SetNumberOfIds(numberOfCells);
  
  int i;

  for (i=0; i<numberOfCells; i++)
    {
    tetraCellIdMap->SetId(i,-1);
    }

  for (i=0; i<numberOfTetras; i++)
    {
    tetraCellIdMap->SetId(tetraCellIdArray->GetValue(i),i);
    }

  vtkIdTypeArray* triangleCellIdArray = vtkIdTypeArray::New();
  input->GetIdsOfCellsOfType(VTK_TRIANGLE,triangleCellIdArray);
  int numberOfTriangles = triangleCellIdArray->GetNumberOfTuples();

  out << "(0 \"Fluent file generated by the Vascular Modeling Toolkit - www.vmtk.org\" )" << endl;
  out << "(0 \"Dimension:\")" << endl;
  out << "(2 3)" << endl;
  out << endl;

  char str[200];

  sprintf(str,"(10 (0 1 %x 1 3))",numberOfPoints);
  out << str << endl;
  sprintf(str,"(10 (1 1 %x 1 3)(",numberOfPoints);
  out << str << endl;

  out.precision(6);

  double point[3];
  for (i=0; i<numberOfPoints; i++)
    {
    input->GetPoint(i,point);
    sprintf(str,"  %17.10e  %17.10e  %17.10e",point[0],point[1],point[2]);
    out << str << endl;
    }
  out << " ))" << endl << endl;

  out << "(0 \"Faces:\")" << endl;

  int numberOfInteriorFaces = 2*numberOfTetras - numberOfTriangles/2;

  sprintf(str,"(13 (0 1 %x 0))",numberOfInteriorFaces+numberOfTriangles);
  out << str << endl; 

  int faceOffset = 1;

  vtkIdList* boundaryDataNumberOfTriangles = vtkIdList::New();
  int boundaryDataRange = static_cast<int>(boundaryDataArray->GetRange()[1]);
  boundaryDataNumberOfTriangles->SetNumberOfIds(boundaryDataRange+1);
  for (i=0; i<boundaryDataRange+1; i++)
    {
    boundaryDataNumberOfTriangles->SetId(i,0);
    }
  int boundaryDataValue, value;
  for (i=0; i<numberOfTriangles; i++)
    {
    vtkIdType triangleCellId = triangleCellIdArray->GetValue(i);
    boundaryDataValue = boundaryDataArray->GetValue(triangleCellId);
    value = boundaryDataNumberOfTriangles->GetId(boundaryDataValue);
    boundaryDataNumberOfTriangles->SetId(boundaryDataValue,value+1);
    }

  vtkIdList* neighborCellIds = vtkIdList::New();
  int n;
  for (n=0; n<boundaryDataRange+1; n++)
    {
    int numberOfBoundaryTriangles = boundaryDataNumberOfTriangles->GetId(n);
    if (numberOfBoundaryTriangles == 0)
      {
      continue;
      }
    sprintf(str,"(13 (7 %x %x 2 0)(",faceOffset,faceOffset+numberOfBoundaryTriangles);
    out << str << endl;
    for (i=0; i<numberOfTriangles; i++)
      {
      vtkIdType triangleCellId = triangleCellIdArray->GetValue(i);
      if (boundaryDataArray->GetValue(triangleCellId) != n)
        {
        continue;
        }
      vtkIdList* cellPointIds = input->GetCell(triangleCellId)->GetPointIds();
      vtkIdType id0 = cellPointIds->GetId(0);
      vtkIdType id1 = cellPointIds->GetId(1);
      vtkIdType id2 = cellPointIds->GetId(2);
      input->GetCellNeighbors(triangleCellId,cellPointIds,neighborCellIds);
      sprintf(str," 3 %x %x %x %x 0",id0+1,id1+1,id2+1,tetraCellIdMap->GetId(neighborCellIds->GetId(0))+1);
      out << str << endl;
      }
    out << "))" << endl << endl;
    faceOffset += numberOfBoundaryTriangles + 1;
    }

  sprintf(str,"(13 (7 %x %x 2 0)(",faceOffset,faceOffset+numberOfInteriorFaces);
  out << str << endl;

//TODO: loop over tets and write interior faces.
//one space, #points on the face, pid1, pid2, pid3, tetraid1, tetraid2
  vtkIdList* facePointIds = vtkIdList::New();
  for (i=0; i<numberOfTetras; i++)
    {
    vtkIdType tetraCellId = tetraCellIdArray->GetValue(i);
    vtkIdList* cellPointIds = input->GetCell(tetraCellId)->GetPointIds();
    int j;
    for (j=0; j<4; j++)
      {
      vtkIdType id0 = cellPointIds->GetId(j);
      vtkIdType id1 = cellPointIds->GetId((j+1)%4);
      vtkIdType id2 = cellPointIds->GetId((j+2)%4);
      facePointIds->Initialize();
      facePointIds->InsertNextId(id0);
      facePointIds->InsertNextId(id1);
      facePointIds->InsertNextId(id2);
      input->GetCellNeighbors(tetraCellId,facePointIds,neighborCellIds);
      if (neighborCellIds->GetNumberOfIds() != 1)
        {
        continue;
        }
      if (neighborCellIds->GetId(0) < tetraCellId)
        {
        continue;
        }
      sprintf(str," 3 %x %x %x %x %x",id0+1,id1+1,id2+1,tetraCellIdMap->GetId(tetraCellId)+1,tetraCellIdMap->GetId(neighborCellIds->GetId(0))+1);
      out << str << endl;
      }
    }
  facePointIds->Delete();
  out << "))" << endl << endl;
  faceOffset += numberOfInteriorFaces + 1;

  neighborCellIds->Delete();

  out << "(0 \"Cells:\")" << endl;
  sprintf(str,"(12 (0 1 %x 0))",numberOfTetras);
  out << str << endl;
  sprintf(str,"(12 (2 1 %x 1 2))",numberOfTetras);
  out << str << endl << endl;

  out << "(0 \"Zones:\")" << endl;
  out << "(45 (2 fluid blood)())" << endl;
  int entityOffset = 3;
  int numberOfBoundaryTriangles = 0;
  for (n=0; n<boundaryDataRange+1; n++)
    {
    numberOfBoundaryTriangles = boundaryDataNumberOfTriangles->GetId(n);
    if (numberOfBoundaryTriangles == 0)
      {
      continue;
      }
    sprintf(str,"(45 (%x wall wall)())",entityOffset);
    out << str << endl;
    entityOffset++;
    }
  sprintf(str,"(45 (%x interior default-interior)())",entityOffset);
  out << str << endl;

  boundaryDataNumberOfTriangles->Delete();
  triangleCellIdArray->Delete();
  tetraCellIdArray->Delete();
  tetraCellIdMap->Delete();
}

void vtkvmtkFluentWriter::PrintSelf(ostream& os, vtkIndent indent)
{
  vtkUnstructuredGridWriter::PrintSelf(os,indent);
}
