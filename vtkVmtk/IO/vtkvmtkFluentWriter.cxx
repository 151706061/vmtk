/*=========================================================================
                                                                                                                                    
Program:   VMTK
Module:    $RCSfile: vtkvmtkFluentWriter.cxx,v $
Language:  C++
Date:      $Date: 2006/04/06 16:47:47 $
Version:   $Revision: 1.6 $
                                                                                                                                    
  Copyright (c) Luca Antiga, David Steinman. All rights reserved.
  See LICENCE file for details.

  Portions of this code are covered under the VTK copyright.
  See VTKCopyright.txt or http://www.kitware.com/VTKCopyright.htm 
  for details.

     This software is distributed WITHOUT ANY WARRANTY; without even 
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
     PURPOSE.  See the above copyright notices for more information.
                                                                                                                                    
=========================================================================*/

// #include <fstream>

#include "vtkvmtkFluentWriter.h"
#include "vtkUnstructuredGrid.h"
#include "vtkCellType.h"
#include "vtkCell.h"
#include "vtkCellData.h"
#include "vtkIdTypeArray.h"
#include "vtkObjectFactory.h"
#include "vtkvmtkConstants.h"

vtkCxxRevisionMacro(vtkvmtkFluentWriter, "$Revision: 1.6 $");
vtkStandardNewMacro(vtkvmtkFluentWriter);

vtkvmtkFluentWriter::vtkvmtkFluentWriter()
{
  this->BoundaryDataArrayName = NULL;
  this->BoundaryDataIdOffset = 0;
}

vtkvmtkFluentWriter::~vtkvmtkFluentWriter()
{
  if (this->BoundaryDataArrayName)
    {
    delete[] this->BoundaryDataArrayName;
    this->BoundaryDataArrayName = NULL;
    }
}

void vtkvmtkFluentWriter::WriteData()
{
  vtkUnstructuredGrid *input= vtkUnstructuredGrid::SafeDownCast(this->GetInput());

  if (!this->FileName)
    {
    vtkErrorMacro(<<"FileName not set.");
    return;
    }
        
  ofstream out (this->FileName);

  if (!out.good())
    {
    vtkErrorMacro(<<"Could not open file for writing.");
    return;
    }
  
  input->BuildLinks();

  int numberOfPoints = input->GetNumberOfPoints();
  int numberOfCells = input->GetNumberOfCells();

  vtkIdTypeArray* boundaryDataArray = NULL;
  if (this->BoundaryDataArrayName)
    {
    if (input->GetCellData()->GetArray(this->BoundaryDataArrayName))
      {
      boundaryDataArray = vtkIdTypeArray::New();
      boundaryDataArray->DeepCopy(input->GetCellData()->GetArray(this->BoundaryDataArrayName));
      }
    else
      {
      vtkErrorMacro(<<"BoundaryDataArray with name specified does not exist");
      }
    }

  vtkIdTypeArray* tetraCellIdArray = vtkIdTypeArray::New();
  input->GetIdsOfCellsOfType(VTK_TETRA,tetraCellIdArray);
  int numberOfTetras = tetraCellIdArray->GetNumberOfTuples();

  vtkIdList* tetraCellIdMap = vtkIdList::New();
  tetraCellIdMap->SetNumberOfIds(numberOfCells);
  
  int i;

  for (i=0; i<numberOfCells; i++)
    {
    tetraCellIdMap->SetId(i,-1);
    }

  for (i=0; i<numberOfTetras; i++)
    {
    tetraCellIdMap->SetId(tetraCellIdArray->GetValue(i),i);
    }

  vtkIdTypeArray* triangleCellIdArray = vtkIdTypeArray::New();
  input->GetIdsOfCellsOfType(VTK_TRIANGLE,triangleCellIdArray);
  int numberOfTriangles = triangleCellIdArray->GetNumberOfTuples();

  out << "(0 \"File generated by the Vascular Modeling Toolkit - www.vmtk.org\" )" << endl;
  out << "(0 \"Dimension:\")" << endl;
  out << "(2 3)" << endl;
  out << endl << endl;

  char str[200];

  sprintf(str,"(10 (0 1 %x 1 3))",numberOfPoints);
  out << str << endl;
  sprintf(str,"(10 (1 1 %x 1 3)(",numberOfPoints);
  out << str << endl;

  out.precision(6);

  double point[3];
  for (i=0; i<numberOfPoints; i++)
    {
    input->GetPoint(i,point);
    out << "   " << point[0] << "   " << point[1] << "   " << point[2] << endl;
    }
  out << " ))" << endl << endl;

  out << "(0 \"Faces:\")" << endl;

  int numberOfInteriorFaces = 2*numberOfTetras - numberOfTriangles/2;

  sprintf(str,"(13 (0 1 %x 0))",numberOfInteriorFaces+numberOfTriangles);
  out << str << endl; 

  int faceOffset = 1;

//TODO: now we write all exterior faces at once, in the future we differentiate between entities
  sprintf(str,"(13 (7 %x %x 2 0)(",faceOffset,faceOffset+numberOfTriangles);
  out << str << endl;

  vtkIdList* neighborCellIds = vtkIdList::New();
  for (i=0; i<numberOfTriangles; i++)
    {
    vtkIdType triangleCellId = triangleCellIdArray->GetValue(i);
    vtkIdList* cellPointIds = input->GetCell(triangleCellId)->GetPointIds();
    vtkIdType id0 = cellPointIds->GetId(0);
    vtkIdType id1 = cellPointIds->GetId(1);
    vtkIdType id2 = cellPointIds->GetId(2);
    input->GetCellNeighbors(triangleCellId,cellPointIds,neighborCellIds);
    sprintf(str," 3 %x %x %x %x 0)(",id0+1,id1+1,id2+1,tetraCellIdMap->GetId(neighborCellIds->GetId(0))+1);
    out << str << endl;
    }

//TODO: loop over faces and write them out (see below for syntax).

  out << "))" << endl << endl;
  faceOffset += numberOfTriangles;

  sprintf(str,"(13 (7 %x %x 2 0)(",faceOffset,faceOffset+numberOfInteriorFaces);
  out << str << endl;

//TODO: loop over tets and write interior faces.
//one space, #points on the face, pid1, pid2, pid3, tetraid1, tetraid2
  vtkIdList* facePointIds = vtkIdList::New();
  for (i=0; i<numberOfTetras; i++)
    {
    vtkIdType tetraCellId = tetraCellIdArray->GetValue(i);
    vtkIdList* cellPointIds = input->GetCell(tetraCellId)->GetPointIds();
    int j;
    for (j=0; j<4; j++)
      {
      vtkIdType id0 = cellPointIds->GetId(j);
      vtkIdType id1 = cellPointIds->GetId((j+1)%4);
      vtkIdType id2 = cellPointIds->GetId((j+2)%4);
      facePointIds->Initialize();
      facePointIds->InsertNextId(id0);
      facePointIds->InsertNextId(id1);
      facePointIds->InsertNextId(id2);
      input->GetCellNeighbors(tetraCellId,facePointIds,neighborCellIds);
      if (neighborCellIds->GetNumberOfIds() != 1)
        {
        continue;
        }
      if (neighborCellIds->GetId(0) < tetraCellId)
        {
        continue;
        }
      sprintf(str," 3 %x %x %x %x %x)(",id0+1,id1+1,id2+1,tetraCellIdMap->GetId(tetraCellId)+1,tetraCellIdMap->GetId(neighborCellIds->GetId(0))+1);
      out << str << endl;
      }
    }
  facePointIds->Delete();
  out << "))" << endl << endl;
  faceOffset += numberOfInteriorFaces;

  neighborCellIds->Delete();

  out << "(0 \"Cells:\")" << endl;
  sprintf(str,"(12 (0 1 %x 0))",numberOfTetras);
  out << str << endl;
  sprintf(str,"(12 (2 1 %x 1 2))",numberOfTetras);
  out << str << endl << endl;

//TODO: FIX THIS
  out << "(0 \"Zones:\")" << endl;
  out << "(45 (2 fluid blood) ())" << endl;
    //      << "(45 (2 velocity-inlet velocity_inlet.1)())\n"
    //      << "(45 (3 pressure-outlet pressure_outlet.2)())\n"
  out << "(45 (3 wall wall) ())" << endl;
  out << "(45 (4 interior default-interior) ())" << endl;

  triangleCellIdArray->Delete();
  tetraCellIdArray->Delete();
  tetraCellIdMap->Delete();
}

void vtkvmtkFluentWriter::PrintSelf(ostream& os, vtkIndent indent)
{
  vtkUnstructuredGridWriter::PrintSelf(os,indent);
}
